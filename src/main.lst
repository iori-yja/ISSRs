   1              		.cpu arm7tdmi-s
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 2
  10              		.eabi_attribute 18, 4
  11              		.file	"main.c"
  19              	.Ltext0:
  20              		.cfi_sections	.debug_frame
  21              		.section	.text.ISSR,"ax",%progbits
  22              		.align	2
  24              	ISSR:
  25              	.LFB5:
  26              		.file 1 "src/main.c"
   1:src/main.c    **** /*
   2:src/main.c    ****     FreeRTOS V6.0.1 - Copyright (C) 2009 Real Time Engineers Ltd.
   3:src/main.c    **** 
   4:src/main.c    ****     ***************************************************************************
   5:src/main.c    ****     *                                                                         *
   6:src/main.c    ****     * If you are:                                                             *
   7:src/main.c    ****     *                                                                         *
   8:src/main.c    ****     *    + New to FreeRTOS,                                                   *
   9:src/main.c    ****     *    + Wanting to learn FreeRTOS or multitasking in general quickly       *
  10:src/main.c    ****     *    + Looking for basic training,                                        *
  11:src/main.c    ****     *    + Wanting to improve your FreeRTOS skills and productivity           *
  12:src/main.c    ****     *                                                                         *
  13:src/main.c    ****     * then take a look at the FreeRTOS eBook                                  *
  14:src/main.c    ****     *                                                                         *
  15:src/main.c    ****     *        "Using the FreeRTOS Real Time Kernel - a Practical Guide"        *
  16:src/main.c    ****     *                  http://www.FreeRTOS.org/Documentation                  *
  17:src/main.c    ****     *                                                                         *
  18:src/main.c    ****     * A pdf reference manual is also available.  Both are usually delivered   *
  19:src/main.c    ****     * to your inbox within 20 minutes to two hours when purchased between 8am *
  20:src/main.c    ****     * and 8pm GMT (although please allow up to 24 hours in case of            *
  21:src/main.c    ****     * exceptional circumstances).  Thank you for your support!                *
  22:src/main.c    ****     *                                                                         *
  23:src/main.c    ****     ***************************************************************************
  24:src/main.c    **** 
  25:src/main.c    ****     This file is part of the FreeRTOS distribution.
  26:src/main.c    **** 
  27:src/main.c    ****     FreeRTOS is free software; you can redistribute it and/or modify it under
  28:src/main.c    ****     the terms of the GNU General Public License (version 2) as published by the
  29:src/main.c    ****     Free Software Foundation AND MODIFIED BY the FreeRTOS exception.
  30:src/main.c    ****     ***NOTE*** The exception to the GPL is included to allow you to distribute
  31:src/main.c    ****     a combined work that includes FreeRTOS without being obliged to provide the
  32:src/main.c    ****     source code for proprietary components outside of the FreeRTOS kernel.
  33:src/main.c    ****     FreeRTOS is distributed in the hope that it will be useful, but WITHOUT
  34:src/main.c    ****     ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  35:src/main.c    ****     FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  36:src/main.c    ****     more details. You should have received a copy of the GNU General Public 
  37:src/main.c    ****     License and the FreeRTOS license exception along with FreeRTOS; if not it 
  38:src/main.c    ****     can be viewed here: http://www.freertos.org/a00114.html and also obtained 
  39:src/main.c    ****     by writing to Richard Barry, contact details for whom are available on the
  40:src/main.c    ****     FreeRTOS WEB site.
  41:src/main.c    **** 
  42:src/main.c    ****     1 tab == 4 spaces!
  43:src/main.c    **** 
  44:src/main.c    ****     http://www.FreeRTOS.org - Documentation, latest information, license and
  45:src/main.c    ****     contact details.
  46:src/main.c    **** 
  47:src/main.c    ****     http://www.SafeRTOS.com - A version that is certified for use in safety
  48:src/main.c    ****     critical systems.
  49:src/main.c    **** 
  50:src/main.c    ****     http://www.OpenRTOS.com - Commercial support, development, porting,
  51:src/main.c    ****     licensing and training services.
  52:src/main.c    **** */
  53:src/main.c    **** 
  54:src/main.c    **** /*
  55:src/main.c    ****  * Creates all the demo application tasks, then starts the scheduler.  The WEB
  56:src/main.c    ****  * documentation provides more details of the standard demo application tasks.
  57:src/main.c    ****  * In addition to the standard demo tasks, the following tasks and tests are
  58:src/main.c    ****  * defined and/or created within this file:
  59:src/main.c    **** *
  60:src/main.c    ****  */
  61:src/main.c    **** 
  62:src/main.c    **** /* Scheduler includes. */
  63:src/main.c    **** #include "FreeRTOS.h"
  64:src/main.c    **** #include "task.h"
  65:src/main.c    **** #include "queue.h"
  66:src/main.c    **** #include "semphr.h"
  67:src/main.c    **** 
  68:src/main.c    **** /* Demo app includes. */
  69:src/main.c    **** #include "BlockQ.h"
  70:src/main.c    **** #include "death.h"
  71:src/main.c    **** #include "blocktim.h"
  72:src/main.c    **** #include "flash.h"
  73:src/main.c    **** #include "partest.h"
  74:src/main.c    **** #include "GenQTest.h"
  75:src/main.c    **** #include "QPeek.h"
  76:src/main.c    **** #include "dynamic.h"
  77:src/main.c    **** #include <string.h>
  78:src/main.c    **** #include <stdio.h>
  79:src/main.c    **** #include "LPC23xx.h"
  80:src/main.c    **** #include "target.h"
  81:src/main.c    **** #include "i2cErr.h"
  82:src/main.c    **** #include "adc.h"
  83:src/main.c    **** static void UARTint (void);
  84:src/main.c    **** static int modechecker (void);
  85:src/main.c    **** static void vLedTask (void *pvParameters);
  86:src/main.c    **** static void vLed2Task (void *pvParameters);
  87:src/main.c    **** static void vi2c (void);
  88:src/main.c    **** static void ISSR (void *pvParameters);
  89:src/main.c    **** static void vHPYTask (void *pvParameters);
  90:src/main.c    **** static void vADcTask (void *pvParameters);
  91:src/main.c    **** static void vrightwheelTask (void *pvParameters);
  92:src/main.c    **** static void vleftwheelTask (void *pvParameters);
  93:src/main.c    **** void vValueTask (void *pvParameters);
  94:src/main.c    **** void vtrsTask (void *pvParameters);
  95:src/main.c    **** unsigned int ADC_Read(unsigned int ch);
  96:src/main.c    **** 
  97:src/main.c    **** /* Demo application definitions. */
  98:src/main.c    **** #define mainQUEUE_SIZE						( 3 )
  99:src/main.c    **** #define mainCHECK_DELAY						( ( portTickType ) 5000 / portTICK_RATE_MS )
 100:src/main.c    **** #define mainBASIC_WEB_STACK_SIZE            ( configMINIMAL_STACK_SIZE * 6 )
 101:src/main.c    **** 
 102:src/main.c    **** /* Task priorities. */
 103:src/main.c    **** #define mainQUEUE_POLL_PRIORITY				( tskIDLE_PRIORITY + 2 )
 104:src/main.c    **** #define mainCHECK_TASK_PRIORITY				( tskIDLE_PRIORITY + 3 )
 105:src/main.c    **** #define mainBLOCK_Q_PRIORITY				( tskIDLE_PRIORITY + 2 )
 106:src/main.c    **** #define mainFLASH_PRIORITY					( tskIDLE_PRIORITY + 2 )
 107:src/main.c    **** #define mainCREATOR_TASK_PRIORITY				( tskIDLE_PRIORITY + 3 )
 108:src/main.c    **** #define mainGEN_QUEUE_TASK_PRIORITY			( tskIDLE_PRIORITY )
 109:src/main.c    **** #define HIGHpriority						( tskIDLE_PRIORITY + 4 )
 110:src/main.c    **** /* Configure the hardware as required by the demo. */
 111:src/main.c    **** static void prvSetupHardware (void);
 112:src/main.c    **** //int rightCycle;
 113:src/main.c    **** //int leftCycle;
 114:src/main.c    **** int i2cErr;
 115:src/main.c    **** //int verti,horizoni;
 116:src/main.c    **** int i2cbuff[6];
 117:src/main.c    **** /* The queue used to send messages to the LCD task. */
 118:src/main.c    **** //xQueueHandle xLCDQueue;
 119:src/main.c    **** int left;
 120:src/main.c    **** int right;
 121:src/main.c    **** xSemaphoreHandle Mutex;
 122:src/main.c    **** 
 123:src/main.c    **** /*-----------------------------------------------------------*/
 124:src/main.c    **** void
 125:src/main.c    **** main (void)
 126:src/main.c    **** {
 127:src/main.c    ****   TargetResetInit ();		//
 128:src/main.c    ****   GPIOResetInit ();
 129:src/main.c    ****   UARTint ();
 130:src/main.c    ****   FIO2PIN1 = 2;
 131:src/main.c    ****   Mutex = xSemaphoreCreateMutex ();
 132:src/main.c    ****   printf (" world!\n");
 133:src/main.c    ****   if(Mutex != NULL){
 134:src/main.c    **** //      xTaskCreate (vLedTask, (signed portCHAR *) "LED",
 135:src/main.c    **** //		   configMINIMAL_STACK_SIZE, NULL,
 136:src/main.c    **** //		   mainCHECK_TASK_PRIORITY - 1, NULL);
 137:src/main.c    ****       /* Start2csender the tasks defined within this file/specific to this demo. */
 138:src/main.c    ****       xTaskCreate (ISSR, (signed portCHAR *) "issr", configMINIMAL_STACK_SIZE,
 139:src/main.c    **** 		   NULL, mainCHECK_TASK_PRIORITY +1, NULL);
 140:src/main.c    ****       xTaskCreate (vi2c, (signed portCHAR *) "LD", configMINIMAL_STACK_SIZE,
 141:src/main.c    **** 		   NULL, mainCHECK_TASK_PRIORITY , NULL);
 142:src/main.c    ****       vTaskStartScheduler ();
 143:src/main.c    ****   FIO2SET1 = 2;
 144:src/main.c    ****   }
 145:src/main.c    ****   while (1);
 146:src/main.c    **** }
 147:src/main.c    **** 
 148:src/main.c    **** //*************************************************************************************************
 149:src/main.c    **** //      -----------------------------In main initializer----------------------------^^
 150:src/main.c    **** /*******UART initialize***************/
 151:src/main.c    **** void
 152:src/main.c    **** UARTint (void)
 153:src/main.c    **** {
 154:src/main.c    ****   DWORD Fdiv, i = 0;
 155:src/main.c    ****   U0LCR = 0x83;			/* 8 bits, no Parity, 1 Stop bit */
 156:src/main.c    ****   Fdiv = (Fpclk / 16) / UART_BAUD;	/*baud rate */
 157:src/main.c    ****   U0DLM = Fdiv / 256;
 158:src/main.c    ****   U0DLL = Fdiv % 256;
 159:src/main.c    ****   U0LCR = 0x03;			/* DLAB = 0 */
 160:src/main.c    ****   U0FCR = 0x07;			/* Enable and reset TX and RX FIFO. */
 161:src/main.c    **** 
 162:src/main.c    ****   printf ("Hello,");
 163:src/main.c    **** }
 164:src/main.c    **** 
 165:src/main.c    **** //---------------------------------------
 166:src/main.c    **** 
 167:src/main.c    **** /*-----------------------------------------------------------*/
 168:src/main.c    **** 
 169:src/main.c    **** //*************************************************************************************************
 170:src/main.c    **** //      ----------------------------------- Routines -------------------------------
 171:src/main.c    **** void
 172:src/main.c    **** getISSI (void)
 173:src/main.c    **** {
 174:src/main.c    ****   int bitshift = 0;
 175:src/main.c    ****   int il = 0;
 176:src/main.c    ****   int prv;
 177:src/main.c    ****   int crr;
 178:src/main.c    ****   vTaskDelay (10 / portTICK_RATE_MS);
 179:src/main.c    ****   while(pdTRUE!=xSemaphoreTake(Mutex, 301 / portTICK_RATE_MS))vTaskDelay( 400 / portTICK_RATE_MS);
 180:src/main.c    ****   printf ("start ISSI connection\n");
 181:src/main.c    ****   while (1)
 182:src/main.c    ****     {
 183:src/main.c    ****       il++;
 184:src/main.c    ****       FIO2SET0 = 1;
 185:src/main.c    ****       prv = FIO2PIN0 & 3;
 186:src/main.c    ****       bitshift = (bitshift << 1) + ((prv & 2) >> 1);
 187:src/main.c    ****       vTaskDelay (100 / portTICK_RATE_MS);
 188:src/main.c    ****       FIO2CLR0 = 1;
 189:src/main.c    **** //      FIO2CLR1 = 2;
 190:src/main.c    ****       FIO2SET1 = 2;
 191:src/main.c    ****       printf ("prv=%x", prv);
 192:src/main.c    ****       crr = FIO0PIN & 3;
 193:src/main.c    ****       printf ("Cr=%d", crr);
 194:src/main.c    ****       if (crr & 2 != prv & 2)
 195:src/main.c    **** 	{
 196:src/main.c    **** 	  printf ("-%d\t%d\n", crr, il);
 197:src/main.c    **** 	  break;
 198:src/main.c    **** 	}
 199:src/main.c    ****       vTaskDelay (100 / portTICK_RATE_MS);
 200:src/main.c    ****     }
 201:src/main.c    **** }
 202:src/main.c    **** 
 203:src/main.c    **** //*************************************************************************************************
 204:src/main.c    **** //      -----------------------------------T A S K s.-------------------------------^^
 205:src/main.c    **** 
 206:src/main.c    **** void
 207:src/main.c    **** vApplicationTickHook (void)
 208:src/main.c    **** {
 209:src/main.c    **** }
 210:src/main.c    **** 
 211:src/main.c    **** /*-----------------------------------------------------------*/
 212:src/main.c    **** void
 213:src/main.c    **** vADcTask (void *pvParameters)
 214:src/main.c    **** {
 215:src/main.c    ****   unsigned int a, t;
 216:src/main.c    ****   unsigned int res[5];
 217:src/main.c    ****   for (;;)
 218:src/main.c    ****     {
 219:src/main.c    ****       for (a = 0; a <= 4; a++)
 220:src/main.c    **** 	{
 221:src/main.c    **** 	  res[a] = ADC_Read (a);
 222:src/main.c    **** 	}
 223:src/main.c    ****       vTaskDelay (30 / portTICK_RATE_MS);
 224:src/main.c    ****     }
 225:src/main.c    **** }
 226:src/main.c    **** 
 227:src/main.c    **** /*-----------------------------------------------------------*/
 228:src/main.c    **** void
 229:src/main.c    **** ISSR (void *pvParameters)
 230:src/main.c    **** {
  27              		.loc 1 230 0
  28              		.cfi_startproc
  29              		@ Function supports interworking.
  30              		@ args = 0, pretend = 0, frame = 0
  31              		@ frame_needed = 0, uses_anonymous_args = 0
  32              	.LVL0:
  33 0000 F0472DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  34              	.LCFI0:
  35              		.cfi_def_cfa_offset 32
 231:src/main.c    ****   unsigned int tmpData = 0;
 232:src/main.c    ****   unsigned int bakData = 0;
 233:src/main.c    ****   int tole = 0;
 234:src/main.c    ****   int cnt = 0;
 235:src/main.c    ****   int cot = 0;
 236:src/main.c    ****   int flg = 0;
 237:src/main.c    ****   vTaskDelay (30 / portTICK_RATE_MS);
  36              		.loc 1 237 0
  37 0004 1E00A0E3 		mov	r0, #30
  38              	.LVL1:
  39              		.cfi_offset 14, -4
  40              		.cfi_offset 10, -8
  41              		.cfi_offset 9, -12
  42              		.cfi_offset 8, -16
  43              		.cfi_offset 7, -20
  44              		.cfi_offset 6, -24
  45              		.cfi_offset 5, -28
  46              		.cfi_offset 4, -32
  47 0008 FEFFFFEB 		bl	vTaskDelay
 238:src/main.c    ****   GPIOInit (1, FAST_PORT, DIR_OUT, LED1_MASK);
  48              		.loc 1 238 0
  49 000c 0100A0E3 		mov	r0, #1
  50 0010 0020A0E1 		mov	r2, r0
  51 0014 0137A0E3 		mov	r3, #262144
  52 0018 0010A0E1 		mov	r1, r0
  53 001c FEFFFFEB 		bl	GPIOInit
 239:src/main.c    ****   FIO2DIR0 = 1;
  54              		.loc 1 239 0
  55 0020 A8319FE5 		ldr	r3, .L16
  56 0024 0120A0E3 		mov	r2, #1
  57 0028 BF2043E5 		strb	r2, [r3, #-191]
  58 002c A0519FE5 		ldr	r5, .L16+4
 240:src/main.c    ****   while (!xSemaphoreTake (Mutex, 300 / portTICK_RATE_MS)) FIO1PIN ^= LED1_MASK;
  59              		.loc 1 240 0
  60 0030 A0419FE5 		ldr	r4, .L16+8
  61 0034 020000EA 		b	.L2
  62              	.L3:
  63              		.loc 1 240 0 is_stmt 0 discriminator 2
  64 0038 CB1F14E5 		ldr	r1, [r4, #-4043]
  65 003c 010721E2 		eor	r0, r1, #262144
  66 0040 CB0F04E5 		str	r0, [r4, #-4043]
  67              	.L2:
  68              		.loc 1 240 0 discriminator 1
  69 0044 0010A0E3 		mov	r1, #0
  70 0048 000095E5 		ldr	r0, [r5, #0]
  71 004c 4B2FA0E3 		mov	r2, #300
  72 0050 0130A0E1 		mov	r3, r1
  73 0054 FEFFFFEB 		bl	xQueueGenericReceive
  74 0058 000050E3 		cmp	r0, #0
  75 005c F5FFFF0A 		beq	.L3
  76              		.loc 1 240 0
  77 0060 0040A0E3 		mov	r4, #0
  78 0064 70619FE5 		ldr	r6, .L16+12
  79 0068 0450A0E1 		mov	r5, r4
  80 006c 04A0A0E1 		mov	sl, r4
  81 0070 0490A0E1 		mov	r9, r4
  82 0074 0470A0E1 		mov	r7, r4
  83 0078 0480A0E1 		mov	r8, r4
  84              	.LVL2:
  85              	.L4:
 241:src/main.c    ****   while(1){
 242:src/main.c    ****  	 while (1){
 243:src/main.c    **** 		  vTaskDelay (1 / portTICK_RATE_MS);
  86              		.loc 1 243 0 is_stmt 1
  87 007c 0100A0E3 		mov	r0, #1
  88 0080 FEFFFFEB 		bl	vTaskDelay
 244:src/main.c    **** 		  if( tole++==0 ){
  89              		.loc 1 244 0
  90 0084 000059E3 		cmp	r9, #0
  91 0088 019089E2 		add	r9, r9, #1
  92              	.LVL3:
  93 008c 2000000A 		beq	.L13
  94              	.L5:
 245:src/main.c    **** 			  FIO1PIN ^= LED1_MASK;
 246:src/main.c    ****   			  FIO2PIN0 ^= 1;
 247:src/main.c    **** 			  flg ^= 1; 
 248:src/main.c    **** 			  fflush(stdout);
 249:src/main.c    **** 			}
 250:src/main.c    **** 		  else if( tole==10 ){
  95              		.loc 1 250 0
  96 0090 0A0059E3 		cmp	r9, #10
  97 0094 2B00000A 		beq	.L14
  98              	.L6:
 251:src/main.c    **** 			  tole = -10;
 252:src/main.c    **** 			  if((flg%2)==1){
 253:src/main.c    **** 				  tmpData = tmpData + ((FIO2PIN0&2)<<cnt++);
 254:src/main.c    **** 			  	  printf("%4x",tmpData>>1);
 255:src/main.c    **** 				  fflush(stdout);
 256:src/main.c    **** 				  printf("T");
 257:src/main.c    **** 				  fflush(stdout);
 258:src/main.c    **** 			  }
 259:src/main.c    **** 			  if ((flg%2)==0){
 260:src/main.c    **** 				  bakData = bakData + ((FIO2PIN0&2)<<cot++);
 261:src/main.c    **** 				  fflush(stdout);
 262:src/main.c    **** 				}
 263:src/main.c    **** 		  }
 264:src/main.c    **** // 	  	  if(cot%12==0 && cnt!=0 && cot!=0)break;
 265:src/main.c    **** 		  if( tole==-10 && (flg%2)==0 && bakData != tmpData )break;
  99              		.loc 1 265 0
 100 0098 0A0079E3 		cmn	r9, #10
 101 009c F6FFFF1A 		bne	.L4
 102 00a0 019004E2 		and	r9, r4, #1
 103              	.LVL4:
 104              	.L10:
 105              		.loc 1 265 0 is_stmt 0 discriminator 1
 106 00a4 019029E2 		eor	r9, r9, #1
 107 00a8 080057E1 		cmp	r7, r8
 108 00ac 0090A003 		moveq	r9, #0
 109 00b0 01900912 		andne	r9, r9, #1
 110 00b4 000059E3 		cmp	r9, #0
 111 00b8 0990E003 		mvneq	r9, #9
 112 00bc EEFFFF0A 		beq	.L4
 266:src/main.c    ****  		} 
 267:src/main.c    **** // 	  if(cot%12==0 && cnt!=0 && cot!=0){
 268:src/main.c    **** //	  if(bakData != tmpData){
 269:src/main.c    **** 		  printf("%x",bakData>>1);
 113              		.loc 1 269 0 is_stmt 1
 114 00c0 A710A0E1 		mov	r1, r7, lsr #1
 115 00c4 14019FE5 		ldr	r0, .L16+16
 116 00c8 FEFFFFEB 		bl	printf
 270:src/main.c    **** 		  fflush(stdout);
 117              		.loc 1 270 0
 118 00cc 005096E5 		ldr	r5, [r6, #0]
 119              	.LVL5:
 120 00d0 080095E5 		ldr	r0, [r5, #8]
 121 00d4 FEFFFFEB 		bl	fflush
 271:src/main.c    **** 		  printf("\n");
 122              		.loc 1 271 0
 123 00d8 0A00A0E3 		mov	r0, #10
 124 00dc FEFFFFEB 		bl	putchar
 272:src/main.c    **** 		  fflush(stdout);
 125              		.loc 1 272 0
 126 00e0 007096E5 		ldr	r7, [r6, #0]
 127              	.LVL6:
 273:src/main.c    **** 		  tole=cnt=tmpData=bakData=cot=0;
 128              		.loc 1 273 0
 129 00e4 0050A0E3 		mov	r5, #0
 272:src/main.c    **** 		  fflush(stdout);
 130              		.loc 1 272 0
 131 00e8 080097E5 		ldr	r0, [r7, #8]
 132 00ec FEFFFFEB 		bl	fflush
 133              	.LVL7:
 134              		.loc 1 273 0
 135 00f0 0590A0E1 		mov	r9, r5
 243:src/main.c    **** 		  vTaskDelay (1 / portTICK_RATE_MS);
 136              		.loc 1 243 0
 137 00f4 0100A0E3 		mov	r0, #1
 138 00f8 FEFFFFEB 		bl	vTaskDelay
 244:src/main.c    **** 		  if( tole++==0 ){
 139              		.loc 1 244 0
 140 00fc 000059E3 		cmp	r9, #0
 141              		.loc 1 273 0
 142 0100 05A0A0E1 		mov	sl, r5
 143 0104 0570A0E1 		mov	r7, r5
 144 0108 0580A0E1 		mov	r8, r5
 145              	.LVL8:
 244:src/main.c    **** 		  if( tole++==0 ){
 146              		.loc 1 244 0
 147 010c 019089E2 		add	r9, r9, #1
 148              	.LVL9:
 149 0110 DEFFFF1A 		bne	.L5
 150              	.LVL10:
 151              	.L13:
 245:src/main.c    **** 			  FIO1PIN ^= LED1_MASK;
 152              		.loc 1 245 0
 153 0114 BC109FE5 		ldr	r1, .L16+8
 154 0118 CBCF11E5 		ldr	ip, [r1, #-4043]
 155 011c 01072CE2 		eor	r0, ip, #262144
 156 0120 CB0F01E5 		str	r0, [r1, #-4043]
 246:src/main.c    ****   			  FIO2PIN0 ^= 1;
 157              		.loc 1 246 0
 158 0124 A4309FE5 		ldr	r3, .L16
 159 0128 AB2053E5 		ldrb	r2, [r3, #-171]	@ zero_extendqisi2
 160 012c 01E022E2 		eor	lr, r2, #1
 161 0130 ABE043E5 		strb	lr, [r3, #-171]
 248:src/main.c    **** 			  fflush(stdout);
 162              		.loc 1 248 0
 163 0134 00C096E5 		ldr	ip, [r6, #0]
 164 0138 08009CE5 		ldr	r0, [ip, #8]
 247:src/main.c    **** 			  flg ^= 1; 
 165              		.loc 1 247 0
 166 013c 014024E2 		eor	r4, r4, #1
 167              	.LVL11:
 248:src/main.c    **** 			  fflush(stdout);
 168              		.loc 1 248 0
 169 0140 FEFFFFEB 		bl	fflush
 170 0144 D3FFFFEA 		b	.L6
 171              	.L14:
 172              	.LVL12:
 252:src/main.c    **** 			  if((flg%2)==1){
 173              		.loc 1 252 0
 174 0148 A4EFA0E1 		mov	lr, r4, lsr #31
 175 014c 0E2084E0 		add	r2, r4, lr
 176 0150 013002E2 		and	r3, r2, #1
 177 0154 03906EE0 		rsb	r9, lr, r3
 178 0158 010059E3 		cmp	r9, #1
 179 015c 0A00000A 		beq	.L15
 180              	.L7:
 259:src/main.c    **** 			  if ((flg%2)==0){
 181              		.loc 1 259 0
 182 0160 019014E2 		ands	r9, r4, #1
 183 0164 CEFFFF1A 		bne	.L10
 260:src/main.c    **** 				  bakData = bakData + ((FIO2PIN0&2)<<cot++);
 184              		.loc 1 260 0
 185 0168 60009FE5 		ldr	r0, .L16
 261:src/main.c    **** 				  fflush(stdout);
 186              		.loc 1 261 0
 187 016c 002096E5 		ldr	r2, [r6, #0]
 260:src/main.c    **** 				  bakData = bakData + ((FIO2PIN0&2)<<cot++);
 188              		.loc 1 260 0
 189 0170 AB1050E5 		ldrb	r1, [r0, #-171]	@ zero_extendqisi2
 261:src/main.c    **** 				  fflush(stdout);
 190              		.loc 1 261 0
 191 0174 080092E5 		ldr	r0, [r2, #8]
 260:src/main.c    **** 				  bakData = bakData + ((FIO2PIN0&2)<<cot++);
 192              		.loc 1 260 0
 193 0178 023001E2 		and	r3, r1, #2
 194 017c 137587E0 		add	r7, r7, r3, asl r5
 195              	.LVL13:
 196 0180 015085E2 		add	r5, r5, #1
 197              	.LVL14:
 261:src/main.c    **** 				  fflush(stdout);
 198              		.loc 1 261 0
 199 0184 FEFFFFEB 		bl	fflush
 200 0188 C5FFFFEA 		b	.L10
 201              	.L15:
 253:src/main.c    **** 				  tmpData = tmpData + ((FIO2PIN0&2)<<cnt++);
 202              		.loc 1 253 0
 203 018c 3CE09FE5 		ldr	lr, .L16
 204 0190 AB905EE5 		ldrb	r9, [lr, #-171]	@ zero_extendqisi2
 205 0194 02C009E2 		and	ip, r9, #2
 206 0198 1C8A88E0 		add	r8, r8, ip, asl sl
 207              	.LVL15:
 254:src/main.c    **** 			  	  printf("%4x",tmpData>>1);
 208              		.loc 1 254 0
 209 019c 40009FE5 		ldr	r0, .L16+20
 210 01a0 A810A0E1 		mov	r1, r8, lsr #1
 211 01a4 FEFFFFEB 		bl	printf
 255:src/main.c    **** 				  fflush(stdout);
 212              		.loc 1 255 0
 213 01a8 001096E5 		ldr	r1, [r6, #0]
 214 01ac 080091E5 		ldr	r0, [r1, #8]
 215 01b0 FEFFFFEB 		bl	fflush
 256:src/main.c    **** 				  printf("T");
 216              		.loc 1 256 0
 217 01b4 5400A0E3 		mov	r0, #84
 218 01b8 FEFFFFEB 		bl	putchar
 257:src/main.c    **** 				  fflush(stdout);
 219              		.loc 1 257 0
 220 01bc 000096E5 		ldr	r0, [r6, #0]
 221 01c0 080090E5 		ldr	r0, [r0, #8]
 253:src/main.c    **** 				  tmpData = tmpData + ((FIO2PIN0&2)<<cnt++);
 222              		.loc 1 253 0
 223 01c4 01A08AE2 		add	sl, sl, #1
 224              	.LVL16:
 257:src/main.c    **** 				  fflush(stdout);
 225              		.loc 1 257 0
 226 01c8 FEFFFFEB 		bl	fflush
 227 01cc E3FFFFEA 		b	.L7
 228              	.L17:
 229              		.align	2
 230              	.L16:
 231 01d0 FFC0FF3F 		.word	1073725695
 232 01d4 00000000 		.word	.LANCHOR0
 233 01d8 FFCFFF3F 		.word	1073729535
 234 01dc 00000000 		.word	_impure_ptr
 235 01e0 04000000 		.word	.LC1
 236 01e4 00000000 		.word	.LC0
 237              		.cfi_endproc
 238              	.LFE5:
 240              		.section	.text.main,"ax",%progbits
 241              		.align	2
 242              		.global	main
 244              	main:
 245              	.LFB0:
 126:src/main.c    **** {
 246              		.loc 1 126 0
 247              		.cfi_startproc
 248              		@ Function supports interworking.
 249              		@ args = 0, pretend = 0, frame = 0
 250              		@ frame_needed = 0, uses_anonymous_args = 0
 251 0000 F0412DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, lr}
 252              	.LCFI1:
 253              		.cfi_def_cfa_offset 24
 254 0004 10D04DE2 		sub	sp, sp, #16
 255              	.LCFI2:
 256              		.cfi_def_cfa_offset 40
 127:src/main.c    ****   TargetResetInit ();		//
 257              		.loc 1 127 0
 258              		.cfi_offset 14, -4
 259              		.cfi_offset 8, -8
 260              		.cfi_offset 7, -12
 261              		.cfi_offset 6, -16
 262              		.cfi_offset 5, -20
 263              		.cfi_offset 4, -24
 264 0008 FEFFFFEB 		bl	TargetResetInit
 128:src/main.c    ****   GPIOResetInit ();
 265              		.loc 1 128 0
 266 000c FEFFFFEB 		bl	GPIOResetInit
 267              	.LVL17:
 268              	.LBB4:
 269              	.LBB6:
 155:src/main.c    ****   U0LCR = 0x83;			/* 8 bits, no Parity, 1 Stop bit */
 270              		.loc 1 155 0
 271 0010 B0109FE5 		ldr	r1, .L21
 272 0014 8330A0E3 		mov	r3, #131
 158:src/main.c    ****   U0DLL = Fdiv % 256;
 273              		.loc 1 158 0
 274 0018 13C0A0E3 		mov	ip, #19
 160:src/main.c    ****   U0FCR = 0x07;			/* Enable and reset TX and RX FIFO. */
 275              		.loc 1 160 0
 276 001c 0720A0E3 		mov	r2, #7
 157:src/main.c    ****   U0DLM = Fdiv / 256;
 277              		.loc 1 157 0
 278 0020 0040A0E3 		mov	r4, #0
 279              	.LBE6:
 280              	.LBE4:
 130:src/main.c    ****   FIO2PIN1 = 2;
 281              		.loc 1 130 0
 282 0024 A0509FE5 		ldr	r5, .L21+4
 283              	.LBB8:
 284              	.LBB5:
 159:src/main.c    ****   U0LCR = 0x03;			/* DLAB = 0 */
 285              		.loc 1 159 0
 286 0028 0370A0E3 		mov	r7, #3
 155:src/main.c    ****   U0LCR = 0x83;			/* 8 bits, no Parity, 1 Stop bit */
 287              		.loc 1 155 0
 288 002c 0C3081E5 		str	r3, [r1, #12]
 289              	.LVL18:
 162:src/main.c    ****   printf ("Hello,");
 290              		.loc 1 162 0
 291 0030 98009FE5 		ldr	r0, .L21+8
 157:src/main.c    ****   U0DLM = Fdiv / 256;
 292              		.loc 1 157 0
 293 0034 044081E5 		str	r4, [r1, #4]
 294              	.LBE5:
 295              	.LBE8:
 130:src/main.c    ****   FIO2PIN1 = 2;
 296              		.loc 1 130 0
 297 0038 0260A0E3 		mov	r6, #2
 298              	.LBB9:
 299              	.LBB7:
 158:src/main.c    ****   U0DLL = Fdiv % 256;
 300              		.loc 1 158 0
 301 003c 00C081E5 		str	ip, [r1, #0]
 159:src/main.c    ****   U0LCR = 0x03;			/* DLAB = 0 */
 302              		.loc 1 159 0
 303 0040 0C7081E5 		str	r7, [r1, #12]
 160:src/main.c    ****   U0FCR = 0x07;			/* Enable and reset TX and RX FIFO. */
 304              		.loc 1 160 0
 305 0044 082081E5 		str	r2, [r1, #8]
 162:src/main.c    ****   printf ("Hello,");
 306              		.loc 1 162 0
 307 0048 FEFFFFEB 		bl	printf
 308              	.LBE7:
 309              	.LBE9:
 130:src/main.c    ****   FIO2PIN1 = 2;
 310              		.loc 1 130 0
 311 004c AA6045E5 		strb	r6, [r5, #-170]
 131:src/main.c    ****   Mutex = xSemaphoreCreateMutex ();
 312              		.loc 1 131 0
 313 0050 FEFFFFEB 		bl	xQueueCreateMutex
 314 0054 78809FE5 		ldr	r8, .L21+12
 315 0058 000088E5 		str	r0, [r8, #0]
 132:src/main.c    ****   printf (" world!\n");
 316              		.loc 1 132 0
 317 005c 74009FE5 		ldr	r0, .L21+16
 318 0060 FEFFFFEB 		bl	puts
 133:src/main.c    ****   if(Mutex != NULL){
 319              		.loc 1 133 0
 320 0064 003098E5 		ldr	r3, [r8, #0]
 321 0068 040053E1 		cmp	r3, r4
 322 006c 1400000A 		beq	.L19
 138:src/main.c    ****       xTaskCreate (ISSR, (signed portCHAR *) "issr", configMINIMAL_STACK_SIZE,
 323              		.loc 1 138 0
 324 0070 04E0A0E3 		mov	lr, #4
 325 0074 60109FE5 		ldr	r1, .L21+20
 326 0078 6820A0E3 		mov	r2, #104
 327 007c 0430A0E1 		mov	r3, r4
 328 0080 58009FE5 		ldr	r0, .L21+24
 329 0084 00E08DE5 		str	lr, [sp, #0]
 330 0088 04408DE5 		str	r4, [sp, #4]
 331 008c 08408DE5 		str	r4, [sp, #8]
 332 0090 0C408DE5 		str	r4, [sp, #12]
 333 0094 FEFFFFEB 		bl	xTaskGenericCreate
 140:src/main.c    ****       xTaskCreate (vi2c, (signed portCHAR *) "LD", configMINIMAL_STACK_SIZE,
 334              		.loc 1 140 0
 335 0098 44109FE5 		ldr	r1, .L21+28
 336 009c 6820A0E3 		mov	r2, #104
 337 00a0 0430A0E1 		mov	r3, r4
 338 00a4 3C009FE5 		ldr	r0, .L21+32
 339 00a8 00708DE5 		str	r7, [sp, #0]
 340 00ac 04408DE5 		str	r4, [sp, #4]
 341 00b0 08408DE5 		str	r4, [sp, #8]
 342 00b4 0C408DE5 		str	r4, [sp, #12]
 343 00b8 FEFFFFEB 		bl	xTaskGenericCreate
 142:src/main.c    ****       vTaskStartScheduler ();
 344              		.loc 1 142 0
 345 00bc FEFFFFEB 		bl	vTaskStartScheduler
 143:src/main.c    ****   FIO2SET1 = 2;
 346              		.loc 1 143 0
 347 00c0 A66045E5 		strb	r6, [r5, #-166]
 348              	.L19:
 349              	.L20:
 350 00c4 FEFFFFEA 		b	.L20
 351              	.L22:
 352              		.align	2
 353              	.L21:
 354 00c8 00C000E0 		.word	-536821760
 355 00cc FFC0FF3F 		.word	1073725695
 356 00d0 08000000 		.word	.LC2
 357 00d4 00000000 		.word	.LANCHOR0
 358 00d8 10000000 		.word	.LC3
 359 00dc 18000000 		.word	.LC4
 360 00e0 00000000 		.word	ISSR
 361 00e4 20000000 		.word	.LC5
 362 00e8 00000000 		.word	vi2c
 363              		.cfi_endproc
 364              	.LFE0:
 366              		.section	.text.getISSI,"ax",%progbits
 367              		.align	2
 368              		.global	getISSI
 370              	getISSI:
 371              	.LFB2:
 173:src/main.c    **** {
 372              		.loc 1 173 0
 373              		.cfi_startproc
 374              		@ Function supports interworking.
 375              		@ args = 0, pretend = 0, frame = 0
 376              		@ frame_needed = 0, uses_anonymous_args = 0
 377              	.LVL19:
 378 0000 F8402DE9 		stmfd	sp!, {r3, r4, r5, r6, r7, lr}
 379              	.LCFI3:
 380              		.cfi_def_cfa_offset 24
 178:src/main.c    ****   vTaskDelay (10 / portTICK_RATE_MS);
 381              		.loc 1 178 0
 382 0004 0A00A0E3 		mov	r0, #10
 383              		.cfi_offset 14, -4
 384              		.cfi_offset 7, -8
 385              		.cfi_offset 6, -12
 386              		.cfi_offset 5, -16
 387              		.cfi_offset 4, -20
 388              		.cfi_offset 3, -24
 389 0008 FEFFFFEB 		bl	vTaskDelay
 390 000c 84409FE5 		ldr	r4, .L28
 179:src/main.c    ****   while(pdTRUE!=xSemaphoreTake(Mutex, 301 / portTICK_RATE_MS))vTaskDelay( 400 / portTICK_RATE_MS);
 391              		.loc 1 179 0
 392 0010 000000EA 		b	.L24
 393              	.L25:
 179:src/main.c    ****   while(pdTRUE!=xSemaphoreTake(Mutex, 301 / portTICK_RATE_MS))vTaskDelay( 400 / portTICK_RATE_MS);
 394              		.loc 1 179 0 is_stmt 0 discriminator 2
 395 0014 FEFFFFEB 		bl	vTaskDelay
 396              	.L24:
 179:src/main.c    ****   while(pdTRUE!=xSemaphoreTake(Mutex, 301 / portTICK_RATE_MS))vTaskDelay( 400 / portTICK_RATE_MS);
 397              		.loc 1 179 0 discriminator 1
 398 0018 0010A0E3 		mov	r1, #0
 399 001c 78209FE5 		ldr	r2, .L28+4
 400 0020 0130A0E1 		mov	r3, r1
 401 0024 000094E5 		ldr	r0, [r4, #0]
 402 0028 FEFFFFEB 		bl	xQueueGenericReceive
 403 002c 010050E3 		cmp	r0, #1
 404 0030 0050A0E1 		mov	r5, r0
 405 0034 190EA0E3 		mov	r0, #400
 406 0038 F5FFFF1A 		bne	.L25
 180:src/main.c    ****   printf ("start ISSI connection\n");
 407              		.loc 1 180 0 is_stmt 1
 408 003c 5C009FE5 		ldr	r0, .L28+8
 409 0040 FEFFFFEB 		bl	puts
 184:src/main.c    ****       FIO2SET0 = 1;
 410              		.loc 1 184 0
 411 0044 58409FE5 		ldr	r4, .L28+12
 412 0048 0560A0E1 		mov	r6, r5
 413              	.LVL20:
 414              	.L27:
 415 004c A76044E5 		strb	r6, [r4, #-167]
 185:src/main.c    ****       prv = FIO2PIN0 & 3;
 416              		.loc 1 185 0
 417 0050 ABC054E5 		ldrb	ip, [r4, #-171]	@ zero_extendqisi2
 187:src/main.c    ****       vTaskDelay (100 / portTICK_RATE_MS);
 418              		.loc 1 187 0
 419 0054 6400A0E3 		mov	r0, #100
 185:src/main.c    ****       prv = FIO2PIN0 & 3;
 420              		.loc 1 185 0
 421 0058 03700CE2 		and	r7, ip, #3
 422              	.LVL21:
 187:src/main.c    ****       vTaskDelay (100 / portTICK_RATE_MS);
 423              		.loc 1 187 0
 424 005c FEFFFFEB 		bl	vTaskDelay
 190:src/main.c    ****       FIO2SET1 = 2;
 425              		.loc 1 190 0
 426 0060 0220A0E3 		mov	r2, #2
 191:src/main.c    ****       printf ("prv=%x", prv);
 427              		.loc 1 191 0
 428 0064 0710A0E1 		mov	r1, r7
 188:src/main.c    ****       FIO2CLR0 = 1;
 429              		.loc 1 188 0
 430 0068 A35044E5 		strb	r5, [r4, #-163]
 191:src/main.c    ****       printf ("prv=%x", prv);
 431              		.loc 1 191 0
 432 006c 34009FE5 		ldr	r0, .L28+16
 190:src/main.c    ****       FIO2SET1 = 2;
 433              		.loc 1 190 0
 434 0070 A62044E5 		strb	r2, [r4, #-166]
 191:src/main.c    ****       printf ("prv=%x", prv);
 435              		.loc 1 191 0
 436 0074 FEFFFFEB 		bl	printf
 192:src/main.c    ****       crr = FIO0PIN & 3;
 437              		.loc 1 192 0
 438 0078 2C309FE5 		ldr	r3, .L28+20
 439 007c EB1F13E5 		ldr	r1, [r3, #-4075]
 193:src/main.c    ****       printf ("Cr=%d", crr);
 440              		.loc 1 193 0
 441 0080 28009FE5 		ldr	r0, .L28+24
 192:src/main.c    ****       crr = FIO0PIN & 3;
 442              		.loc 1 192 0
 443 0084 031001E2 		and	r1, r1, #3
 444              	.LVL22:
 193:src/main.c    ****       printf ("Cr=%d", crr);
 445              		.loc 1 193 0
 446 0088 FEFFFFEB 		bl	printf
 447              	.LVL23:
 199:src/main.c    ****       vTaskDelay (100 / portTICK_RATE_MS);
 448              		.loc 1 199 0
 449 008c 6400A0E3 		mov	r0, #100
 450 0090 FEFFFFEB 		bl	vTaskDelay
 200:src/main.c    ****     }
 451              		.loc 1 200 0
 452 0094 ECFFFFEA 		b	.L27
 453              	.L29:
 454              		.align	2
 455              	.L28:
 456 0098 00000000 		.word	.LANCHOR0
 457 009c 2D010000 		.word	301
 458 00a0 24000000 		.word	.LC6
 459 00a4 FFC0FF3F 		.word	1073725695
 460 00a8 3C000000 		.word	.LC7
 461 00ac FFCFFF3F 		.word	1073729535
 462 00b0 44000000 		.word	.LC8
 463              		.cfi_endproc
 464              	.LFE2:
 466              		.section	.text.vApplicationTickHook,"ax",%progbits
 467              		.align	2
 468              		.global	vApplicationTickHook
 470              	vApplicationTickHook:
 471              	.LFB3:
 208:src/main.c    **** {
 472              		.loc 1 208 0
 473              		.cfi_startproc
 474              		@ Function supports interworking.
 475              		@ args = 0, pretend = 0, frame = 0
 476              		@ frame_needed = 0, uses_anonymous_args = 0
 477              		@ link register save eliminated.
 209:src/main.c    **** }
 478              		.loc 1 209 0
 479 0000 1EFF2FE1 		bx	lr
 480              		.cfi_endproc
 481              	.LFE3:
 483              		.section	.text.vtrsTask,"ax",%progbits
 484              		.align	2
 485              		.global	vtrsTask
 487              	vtrsTask:
 488              	.LFB7:
 274:src/main.c    ****   }
 275:src/main.c    ****   FIO2CLR1 = 0xFF;
 276:src/main.c    ****   while (1)
 277:src/main.c    ****     {
 278:src/main.c    ****       getISSI ();
 279:src/main.c    ****       vTaskDelay (300 / portTICK_RATE_MS);
 280:src/main.c    ****     }
 281:src/main.c    **** }
 282:src/main.c    **** 
 283:src/main.c    **** /*-----------------------------------------------------------*/
 284:src/main.c    **** unsigned int res[5];
 285:src/main.c    **** int white, black;
 286:src/main.c    **** //-----------------
 287:src/main.c    **** void
 288:src/main.c    **** vValueTask (void *pvParameters)
 289:src/main.c    **** {
 290:src/main.c    ****   int i;
 291:src/main.c    ****   unsigned int a, t;
 292:src/main.c    ****   vTaskDelay (30 / portTICK_RATE_MS);
 293:src/main.c    ****   for (white = 0, black = 0, i = 1; i <= 20; i++)
 294:src/main.c    ****     {
 295:src/main.c    ****       for (a = 0; a <= 7; a++)
 296:src/main.c    **** 	{
 297:src/main.c    **** 	  res[a] = ADC_Read (a);
 298:src/main.c    **** 	  printf ("  %x....%4x\t", a, res[a]);
 299:src/main.c    **** 	}
 300:src/main.c    ****       printf ("\n");
 301:src/main.c    ****       white += ((res[1] + res[3] + res[4]) / 3);
 302:src/main.c    ****       black += (res[2]);
 303:src/main.c    ****     }
 304:src/main.c    **** //      white = (white / 20);
 305:src/main.c    **** //      black = (black / 20);
 306:src/main.c    **** //      printf("white %x, black %x", white, black);
 307:src/main.c    **** //      write_ROM(0x1A, 32, white);             //(int subadr, int size, int Data)
 308:src/main.c    **** //      write_ROM(0x2A, 32, black);             //(int subadr, int size, int Data)
 309:src/main.c    ****   while (1)
 310:src/main.c    ****     {
 311:src/main.c    ****       for (a = 0; a <= 4; a++)
 312:src/main.c    **** 	{
 313:src/main.c    **** 	  res[a] = ADC_Read (a);
 314:src/main.c    **** 	  printf ("%d\t", res[a]);
 315:src/main.c    **** 	  vTaskDelay (3 / portTICK_RATE_MS);
 316:src/main.c    **** 	}
 317:src/main.c    ****       printf ("\n");
 318:src/main.c    ****     }
 319:src/main.c    **** }
 320:src/main.c    **** 
 321:src/main.c    **** void
 322:src/main.c    **** vtrsTask (void *pvParameters)
 323:src/main.c    **** {
 489              		.loc 1 323 0
 490              		.cfi_startproc
 491              		@ Function supports interworking.
 492              		@ args = 0, pretend = 0, frame = 0
 493              		@ frame_needed = 0, uses_anonymous_args = 0
 494              	.LVL24:
 495 0000 F84F2DE9 		stmfd	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 496              	.LCFI4:
 497              		.cfi_def_cfa_offset 40
 324:src/main.c    ****   vTaskDelay (300 / portTICK_RATE_MS);
 498              		.loc 1 324 0
 499 0004 4B0FA0E3 		mov	r0, #300
 500              	.LVL25:
 501              		.cfi_offset 14, -4
 502              		.cfi_offset 11, -8
 503              		.cfi_offset 10, -12
 504              		.cfi_offset 9, -16
 505              		.cfi_offset 8, -20
 506              		.cfi_offset 7, -24
 507              		.cfi_offset 6, -28
 508              		.cfi_offset 5, -32
 509              		.cfi_offset 4, -36
 510              		.cfi_offset 3, -40
 511 0008 FEFFFFEB 		bl	vTaskDelay
 512 000c F0409FE5 		ldr	r4, .L49
 513 0010 F0809FE5 		ldr	r8, .L49+4
 514 0014 F0709FE5 		ldr	r7, .L49+8
 515 0018 F0909FE5 		ldr	r9, .L49+12
 516 001c F0A09FE5 		ldr	sl, .L49+16
 325:src/main.c    ****   for (;;)
 326:src/main.c    ****     {
 327:src/main.c    ****       if ((2 * res[6]) <= (white + black))
 517              		.loc 1 327 0
 518 0020 0460A0E1 		mov	r6, r4
 519 0024 0450A0E1 		mov	r5, r4
 520              	.L38:
 324:src/main.c    ****   vTaskDelay (300 / portTICK_RATE_MS);
 521              		.loc 1 324 0
 522 0028 002098E5 		ldr	r2, [r8, #0]
 523 002c 003097E5 		ldr	r3, [r7, #0]
 328:src/main.c    **** 	{
 329:src/main.c    **** 	  printf ("migi");
 330:src/main.c    **** 	  left = 0;
 331:src/main.c    **** 	  right = 10;
 524              		.loc 1 331 0
 525 0030 0AB0A0E3 		mov	fp, #10
 526 0034 033082E0 		add	r3, r2, r3
 527 0038 020000EA 		b	.L35
 528              	.L32:
 332:src/main.c    **** 	  while ((2 * res[2]) <= (white + black)
 333:src/main.c    **** 		 || ((2 * res[3]) <= (white + black))
 334:src/main.c    **** 		 || ((2 * res[4]) <= (white + black)));
 335:src/main.c    **** 	  left = 10;
 336:src/main.c    **** 	  right = 10;
 337:src/main.c    **** 	}
 338:src/main.c    ****       if ((2 * res[4]) <= ((white + black)))
 529              		.loc 1 338 0
 530 003c 10E094E5 		ldr	lr, [r4, #16]
 531 0040 8E0053E1 		cmp	r3, lr, asl #1
 532 0044 1600002A 		bcs	.L48
 533              	.L35:
 327:src/main.c    ****       if ((2 * res[6]) <= (white + black))
 534              		.loc 1 327 0
 535 0048 180094E5 		ldr	r0, [r4, #24]
 536 004c 800053E1 		cmp	r3, r0, asl #1
 537 0050 F9FFFF3A 		bcc	.L32
 329:src/main.c    **** 	  printf ("migi");
 538              		.loc 1 329 0
 539 0054 BC009FE5 		ldr	r0, .L49+20
 540 0058 FEFFFFEB 		bl	printf
 331:src/main.c    **** 	  right = 10;
 541              		.loc 1 331 0
 542 005c 081096E5 		ldr	r1, [r6, #8]
 543 0060 003098E5 		ldr	r3, [r8, #0]
 544 0064 00C097E5 		ldr	ip, [r7, #0]
 545 0068 0C2096E5 		ldr	r2, [r6, #12]
 546 006c 100096E5 		ldr	r0, [r6, #16]
 547 0070 00B089E5 		str	fp, [r9, #0]
 548 0074 8110A0E1 		mov	r1, r1, asl #1
 549 0078 03308CE0 		add	r3, ip, r3
 550 007c 8220A0E1 		mov	r2, r2, asl #1
 551 0080 8000A0E1 		mov	r0, r0, asl #1
 552              	.L44:
 332:src/main.c    **** 	  while ((2 * res[2]) <= (white + black)
 553              		.loc 1 332 0 discriminator 1
 554 0084 030051E1 		cmp	r1, r3
 555 0088 1C00009A 		bls	.L33
 333:src/main.c    **** 		 || ((2 * res[3]) <= (white + black))
 556              		.loc 1 333 0
 557 008c 020053E1 		cmp	r3, r2
 558 0090 FBFFFF2A 		bcs	.L44
 334:src/main.c    **** 		 || ((2 * res[4]) <= (white + black)));
 559              		.loc 1 334 0
 560 0094 000053E1 		cmp	r3, r0
 561 0098 F9FFFF2A 		bcs	.L44
 335:src/main.c    **** 	  left = 10;
 562              		.loc 1 335 0
 563 009c 00B08AE5 		str	fp, [sl, #0]
 564 00a0 E5FFFFEA 		b	.L32
 565              	.L48:
 339:src/main.c    **** 	{
 340:src/main.c    **** 	  printf ("tyuou");
 566              		.loc 1 340 0
 567 00a4 70009FE5 		ldr	r0, .L49+24
 568 00a8 FEFFFFEB 		bl	printf
 341:src/main.c    **** 	  left = 10;
 569              		.loc 1 341 0
 570 00ac 002098E5 		ldr	r2, [r8, #0]
 571 00b0 0C0095E5 		ldr	r0, [r5, #12]
 572 00b4 08C095E5 		ldr	ip, [r5, #8]
 573 00b8 003097E5 		ldr	r3, [r7, #0]
 574 00bc 10B095E5 		ldr	fp, [r5, #16]
 575 00c0 0A10A0E3 		mov	r1, #10
 576 00c4 00108AE5 		str	r1, [sl, #0]
 577 00c8 023083E0 		add	r3, r3, r2
 578 00cc 8C10A0E1 		mov	r1, ip, asl #1
 579 00d0 8020A0E1 		mov	r2, r0, asl #1
 580 00d4 8B00A0E1 		mov	r0, fp, asl #1
 581              	.L45:
 342:src/main.c    **** 	  right = 0;
 343:src/main.c    **** 	  while (((2 * res[2]) <= (white + black))
 582              		.loc 1 343 0 discriminator 1
 583 00d8 030051E1 		cmp	r1, r3
 584 00dc 0600009A 		bls	.L36
 344:src/main.c    **** 		 || ((2 * res[3]) <= (white + black))
 585              		.loc 1 344 0
 586 00e0 020053E1 		cmp	r3, r2
 587 00e4 FBFFFF2A 		bcs	.L45
 345:src/main.c    **** 		 || ((2 * res[4]) <= (white + black)));
 588              		.loc 1 345 0
 589 00e8 000053E1 		cmp	r3, r0
 590 00ec F9FFFF2A 		bcs	.L45
 346:src/main.c    **** 	  left = 10;
 347:src/main.c    **** 	  right = 10;
 591              		.loc 1 347 0
 592 00f0 0AE0A0E3 		mov	lr, #10
 593 00f4 00E089E5 		str	lr, [r9, #0]
 594 00f8 CAFFFFEA 		b	.L38
 595              	.L36:
 596              	.L46:
 597 00fc FEFFFFEA 		b	.L46
 598              	.L33:
 599              	.L47:
 600 0100 FEFFFFEA 		b	.L47
 601              	.L50:
 602              		.align	2
 603              	.L49:
 604 0104 00000000 		.word	.LANCHOR3
 605 0108 00000000 		.word	.LANCHOR1
 606 010c 00000000 		.word	.LANCHOR2
 607 0110 00000000 		.word	.LANCHOR4
 608 0114 00000000 		.word	.LANCHOR5
 609 0118 54000000 		.word	.LC10
 610 011c 5C000000 		.word	.LC11
 611              		.cfi_endproc
 612              	.LFE7:
 614              		.section	.text.ADC_Read,"ax",%progbits
 615              		.align	2
 616              		.global	ADC_Read
 618              	ADC_Read:
 619              	.LFB12:
 348:src/main.c    **** 	}
 349:src/main.c    **** //              vTaskDelay(30 / portTICK_RATE_MS);
 350:src/main.c    **** 
 351:src/main.c    ****     }
 352:src/main.c    **** }
 353:src/main.c    **** 
 354:src/main.c    **** //**           **GPIO TASK**          **
 355:src/main.c    **** /*-----------------------------------------------------------*/
 356:src/main.c    **** void
 357:src/main.c    **** vLedTask (void *pvParameters)
 358:src/main.c    **** {
 359:src/main.c    ****   GPIOInit (1, FAST_PORT, DIR_OUT, LED1_MASK);
 360:src/main.c    **** 
 361:src/main.c    ****   for (;;)
 362:src/main.c    ****     {
 363:src/main.c    ****       FIO1PIN ^= LED1_MASK;
 364:src/main.c    ****       vTaskDelay (207 / portTICK_RATE_MS);
 365:src/main.c    ****     }
 366:src/main.c    **** 
 367:src/main.c    **** }
 368:src/main.c    **** 
 369:src/main.c    **** //----------------------------------------------------------
 370:src/main.c    **** void
 371:src/main.c    **** vLed2Task (void *pvParameters)
 372:src/main.c    **** {
 373:src/main.c    ****   for (;;)
 374:src/main.c    ****     {
 375:src/main.c    ****       FIO2PIN1 ^= 0x02;
 376:src/main.c    ****       vTaskDelay (300 / portTICK_RATE_MS);
 377:src/main.c    ****     }
 378:src/main.c    **** 
 379:src/main.c    **** }
 380:src/main.c    **** 
 381:src/main.c    **** //TODO 衝突検知　
 382:src/main.c    **** /*-----------------------------------------------------------
 383:src/main.c    **** 		for(a = 0; a <= 4; a++){
 384:src/main.c    **** 			res[a] = ADC_Read(a);
 385:src/main.c    **** 			printf("  %x....%4x\t", a, res[a] );
 386:src/main.c    **** 		}
 387:src/main.c    **** 
 388:src/main.c    **** void vHPYTask( void *pvParameters )
 389:src/main.c    **** {	
 390:src/main.c    **** int phase = 0;
 391:src/main.c    **** unsigned int Step[4] = {0x6, 0xC, 0x9, 0x3}
 392:src/main.c    **** 
 393:src/main.c    **** for(;;)
 394:src/main.c    **** {
 395:src/main.c    **** 	if(){ 
 396:src/main.c    **** 	FIO4CLR0 = 0x0F;
 397:src/main.c    **** 	}
 398:src/main.c    **** }
 399:src/main.c    **** 
 400:src/main.c    **** }
 401:src/main.c    **** 
 402:src/main.c    **** 
 403:src/main.c    **** -----------------------------------------------------------*/
 404:src/main.c    **** void
 405:src/main.c    **** vrightwheelTask (void *pvParameters)
 406:src/main.c    **** {
 407:src/main.c    ****   int phase;
 408:src/main.c    ****   FIO4DIR0 = 0x0F;
 409:src/main.c    ****   FIO4CLR0 = 0x0F;
 410:src/main.c    ****   while (1)
 411:src/main.c    ****     {
 412:src/main.c    ****       if (0 != right)
 413:src/main.c    **** 	{
 414:src/main.c    **** 	  switch (phase)
 415:src/main.c    **** 	    {
 416:src/main.c    **** 	    case 0:
 417:src/main.c    **** 	      FIO4PIN0 = 0x03;
 418:src/main.c    **** 	      phase++;
 419:src/main.c    **** 	      break;
 420:src/main.c    **** 	    case 1:
 421:src/main.c    **** 	      FIO4PIN0 = 0x09;
 422:src/main.c    **** 	      phase++;
 423:src/main.c    **** 	      break;
 424:src/main.c    **** 	    case 2:
 425:src/main.c    **** 	      FIO4PIN0 = 0x0C;
 426:src/main.c    **** 	      phase++;
 427:src/main.c    **** 	      break;
 428:src/main.c    **** 	    case 3:
 429:src/main.c    **** 	      FIO4PIN0 = 0x06;
 430:src/main.c    **** 	    default:
 431:src/main.c    **** 	      phase = 0;
 432:src/main.c    **** 	      break;
 433:src/main.c    **** 	    }
 434:src/main.c    **** 	  vTaskDelay (right / portTICK_RATE_MS);
 435:src/main.c    **** 	}
 436:src/main.c    ****       else
 437:src/main.c    **** 	vTaskDelay (10 / portTICK_RATE_MS);
 438:src/main.c    **** 
 439:src/main.c    ****     }
 440:src/main.c    **** }
 441:src/main.c    **** 
 442:src/main.c    **** //============================
 443:src/main.c    **** void
 444:src/main.c    **** vleftwheelTask (void *pvPatameters)
 445:src/main.c    **** {
 446:src/main.c    ****   int phase;
 447:src/main.c    ****   FIO4DIR1 = 0x0F;
 448:src/main.c    ****   FIO4CLR1 = 0x0F;
 449:src/main.c    ****   while (1)
 450:src/main.c    ****     {
 451:src/main.c    ****       if (0 != left)
 452:src/main.c    **** 	{
 453:src/main.c    **** 	  switch (phase)
 454:src/main.c    **** 	    {
 455:src/main.c    **** 	    case 0:
 456:src/main.c    **** 	      FIO4PIN1 = 0x03;
 457:src/main.c    **** 	      phase++;
 458:src/main.c    **** 	      break;
 459:src/main.c    **** 	    case 1:
 460:src/main.c    **** 	      FIO4PIN1 = 0x09;
 461:src/main.c    **** 	      phase++;
 462:src/main.c    **** 	      break;
 463:src/main.c    **** 	    case 2:
 464:src/main.c    **** 	      FIO4PIN1 = 0x0C;
 465:src/main.c    **** 	      phase++;
 466:src/main.c    **** 	      break;
 467:src/main.c    **** 	    case 3:
 468:src/main.c    **** 	      FIO4PIN1 = 0x06;
 469:src/main.c    **** 	    default:
 470:src/main.c    **** 	      phase = 0;
 471:src/main.c    **** 	      break;
 472:src/main.c    **** 	    }
 473:src/main.c    **** 	  vTaskDelay (left / portTICK_RATE_MS);
 474:src/main.c    **** 	}
 475:src/main.c    ****       else
 476:src/main.c    **** 	vTaskDelay (left / portTICK_RATE_MS);
 477:src/main.c    ****     }
 478:src/main.c    **** }
 479:src/main.c    **** unsigned int
 480:src/main.c    **** ADC_Read (unsigned int ch)
 481:src/main.c    **** {
 620              		.loc 1 481 0
 621              		.cfi_startproc
 622              		@ Function supports interworking.
 623              		@ args = 0, pretend = 0, frame = 0
 624              		@ frame_needed = 0, uses_anonymous_args = 0
 625              		@ link register save eliminated.
 626              	.LVL26:
 482:src/main.c    ****   unsigned int i;
 483:src/main.c    ****   AD0CR = (0x00200400 | (1 << ch));	// Init ADC (Pclk = 18MHz) and select channel. Sampling rate = 
 627              		.loc 1 483 0
 628 0000 0120A0E3 		mov	r2, #1
 629 0004 1210A0E1 		mov	r1, r2, asl r0
 630 0008 C8209FE5 		ldr	r2, .L65
 631 000c 02C681E3 		orr	ip, r1, #2097152
 632 0010 011B8CE3 		orr	r1, ip, #1024
 633 0014 001082E5 		str	r1, [r2, #0]
 484:src/main.c    ****   AD0CR |= 0x01000000;		// Start A/D Conversion
 634              		.loc 1 484 0
 635 0018 00C092E5 		ldr	ip, [r2, #0]
 636 001c 01148CE3 		orr	r1, ip, #16777216
 637 0020 001082E5 		str	r1, [r2, #0]
 638              	.L62:
 639              	.LVL27:
 485:src/main.c    ****   do
 486:src/main.c    ****     {
 487:src/main.c    ****       switch (ch)
 640              		.loc 1 487 0
 641 0024 070050E3 		cmp	r0, #7
 642 0028 00F19F97 		ldrls	pc, [pc, r0, asl #2]
 643 002c 080000EA 		b	.L52
 644              	.L61:
 645 0030 98000000 		.word	.L53
 646 0034 88000000 		.word	.L54
 647 0038 78000000 		.word	.L55
 648 003c 68000000 		.word	.L56
 649 0040 B8000000 		.word	.L57
 650 0044 A8000000 		.word	.L58
 651 0048 C8000000 		.word	.L59
 652 004c 50000000 		.word	.L60
 653              	.L60:
 488:src/main.c    **** 	{
 489:src/main.c    **** 	case 0:
 490:src/main.c    **** 	  i = AD0DR0;		// Read A/D Data Register
 491:src/main.c    **** 	  break;
 492:src/main.c    **** 	case 1:
 493:src/main.c    **** 	  i = AD0DR1;
 494:src/main.c    **** 	  break;
 495:src/main.c    **** 	case 2:
 496:src/main.c    **** 	  i = AD0DR2;
 497:src/main.c    **** 	  break;
 498:src/main.c    **** 	case 3:
 499:src/main.c    **** 	  i = AD0DR3;
 500:src/main.c    **** 	  break;
 501:src/main.c    **** 	case 4:
 502:src/main.c    **** 	  i = AD0DR4;
 503:src/main.c    **** 	  break;
 504:src/main.c    **** 	case 5:
 505:src/main.c    **** 	  i = AD0DR5;
 506:src/main.c    **** 	  break;
 507:src/main.c    **** 	case 6:
 508:src/main.c    **** 	  i = AD0DR6;
 509:src/main.c    **** 	  break;
 510:src/main.c    **** 	case 7:
 511:src/main.c    **** 	  i = AD0DR7;
 654              		.loc 1 511 0
 655 0050 2C3092E5 		ldr	r3, [r2, #44]
 656              	.LVL28:
 657              	.L52:
 512:src/main.c    **** 	  break;
 513:src/main.c    **** 	}
 514:src/main.c    **** 
 515:src/main.c    ****     }
 516:src/main.c    ****   while ((i & 0x80000000) == 0);	// Wait for end of A/D Conversion
 658              		.loc 1 516 0
 659 0054 000053E3 		cmp	r3, #0
 660 0058 F1FFFFAA 		bge	.L62
 661              	.L64:
 517:src/main.c    ****   return (i >> 6) & 0x03FF;	// bit 6:15 is 10 bit AD value
 662              		.loc 1 517 0
 663 005c 0338A0E1 		mov	r3, r3, asl #16
 664              	.LVL29:
 518:src/main.c    **** }
 665              		.loc 1 518 0
 666 0060 230BA0E1 		mov	r0, r3, lsr #22
 667              	.LVL30:
 668 0064 1EFF2FE1 		bx	lr
 669              	.LVL31:
 670              	.L56:
 499:src/main.c    **** 	  i = AD0DR3;
 671              		.loc 1 499 0
 672 0068 1C3092E5 		ldr	r3, [r2, #28]
 673              	.LVL32:
 516:src/main.c    ****   while ((i & 0x80000000) == 0);	// Wait for end of A/D Conversion
 674              		.loc 1 516 0
 675 006c 000053E3 		cmp	r3, #0
 676 0070 EBFFFFAA 		bge	.L62
 677 0074 F8FFFFEA 		b	.L64
 678              	.L55:
 496:src/main.c    **** 	  i = AD0DR2;
 679              		.loc 1 496 0
 680 0078 183092E5 		ldr	r3, [r2, #24]
 681              	.LVL33:
 516:src/main.c    ****   while ((i & 0x80000000) == 0);	// Wait for end of A/D Conversion
 682              		.loc 1 516 0
 683 007c 000053E3 		cmp	r3, #0
 684 0080 E7FFFFAA 		bge	.L62
 685 0084 F4FFFFEA 		b	.L64
 686              	.L54:
 493:src/main.c    **** 	  i = AD0DR1;
 687              		.loc 1 493 0
 688 0088 143092E5 		ldr	r3, [r2, #20]
 689              	.LVL34:
 516:src/main.c    ****   while ((i & 0x80000000) == 0);	// Wait for end of A/D Conversion
 690              		.loc 1 516 0
 691 008c 000053E3 		cmp	r3, #0
 692 0090 E3FFFFAA 		bge	.L62
 693 0094 F0FFFFEA 		b	.L64
 694              	.L53:
 490:src/main.c    **** 	  i = AD0DR0;		// Read A/D Data Register
 695              		.loc 1 490 0
 696 0098 103092E5 		ldr	r3, [r2, #16]
 697              	.LVL35:
 516:src/main.c    ****   while ((i & 0x80000000) == 0);	// Wait for end of A/D Conversion
 698              		.loc 1 516 0
 699 009c 000053E3 		cmp	r3, #0
 700 00a0 DFFFFFAA 		bge	.L62
 701 00a4 ECFFFFEA 		b	.L64
 702              	.L58:
 505:src/main.c    **** 	  i = AD0DR5;
 703              		.loc 1 505 0
 704 00a8 243092E5 		ldr	r3, [r2, #36]
 705              	.LVL36:
 516:src/main.c    ****   while ((i & 0x80000000) == 0);	// Wait for end of A/D Conversion
 706              		.loc 1 516 0
 707 00ac 000053E3 		cmp	r3, #0
 708 00b0 DBFFFFAA 		bge	.L62
 709 00b4 E8FFFFEA 		b	.L64
 710              	.L57:
 502:src/main.c    **** 	  i = AD0DR4;
 711              		.loc 1 502 0
 712 00b8 203092E5 		ldr	r3, [r2, #32]
 713              	.LVL37:
 516:src/main.c    ****   while ((i & 0x80000000) == 0);	// Wait for end of A/D Conversion
 714              		.loc 1 516 0
 715 00bc 000053E3 		cmp	r3, #0
 716 00c0 D7FFFFAA 		bge	.L62
 717 00c4 E4FFFFEA 		b	.L64
 718              	.L59:
 508:src/main.c    **** 	  i = AD0DR6;
 719              		.loc 1 508 0
 720 00c8 283092E5 		ldr	r3, [r2, #40]
 721              	.LVL38:
 516:src/main.c    ****   while ((i & 0x80000000) == 0);	// Wait for end of A/D Conversion
 722              		.loc 1 516 0
 723 00cc 000053E3 		cmp	r3, #0
 724 00d0 D3FFFFAA 		bge	.L62
 725 00d4 E0FFFFEA 		b	.L64
 726              	.L66:
 727              		.align	2
 728              	.L65:
 729 00d8 004003E0 		.word	-536657920
 730              		.cfi_endproc
 731              	.LFE12:
 733              		.section	.text.vValueTask,"ax",%progbits
 734              		.align	2
 735              		.global	vValueTask
 737              	vValueTask:
 738              	.LFB6:
 289:src/main.c    **** {
 739              		.loc 1 289 0
 740              		.cfi_startproc
 741              		@ Function supports interworking.
 742              		@ args = 0, pretend = 0, frame = 0
 743              		@ frame_needed = 0, uses_anonymous_args = 0
 744              	.LVL39:
 745 0000 F0412DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, lr}
 746              	.LCFI5:
 747              		.cfi_def_cfa_offset 24
 292:src/main.c    ****   vTaskDelay (30 / portTICK_RATE_MS);
 748              		.loc 1 292 0
 749 0004 1E00A0E3 		mov	r0, #30
 750              	.LVL40:
 293:src/main.c    ****   for (white = 0, black = 0, i = 1; i <= 20; i++)
 751              		.loc 1 293 0
 752 0008 A8719FE5 		ldr	r7, .L75
 753              		.cfi_offset 14, -4
 754              		.cfi_offset 8, -8
 755              		.cfi_offset 7, -12
 756              		.cfi_offset 6, -16
 757              		.cfi_offset 5, -20
 758              		.cfi_offset 4, -24
 759 000c A8619FE5 		ldr	r6, .L75+4
 292:src/main.c    ****   vTaskDelay (30 / portTICK_RATE_MS);
 760              		.loc 1 292 0
 761 0010 FEFFFFEB 		bl	vTaskDelay
 293:src/main.c    ****   for (white = 0, black = 0, i = 1; i <= 20; i++)
 762              		.loc 1 293 0
 763 0014 0030A0E3 		mov	r3, #0
 764 0018 003087E5 		str	r3, [r7, #0]
 765 001c 003086E5 		str	r3, [r6, #0]
 766              	.LVL41:
 767 0020 98419FE5 		ldr	r4, .L75+8
 301:src/main.c    ****       white += ((res[1] + res[3] + res[4]) / 3);
 768              		.loc 1 301 0
 769 0024 98819FE5 		ldr	r8, .L75+12
 293:src/main.c    ****   for (white = 0, black = 0, i = 1; i <= 20; i++)
 770              		.loc 1 293 0
 771 0028 1450A0E3 		mov	r5, #20
 772              	.LVL42:
 773              	.L68:
 297:src/main.c    **** 	  res[a] = ADC_Read (a);
 774              		.loc 1 297 0 discriminator 1
 775 002c 0000A0E3 		mov	r0, #0
 776 0030 FEFFFFEB 		bl	ADC_Read
 298:src/main.c    **** 	  printf ("  %x....%4x\t", a, res[a]);
 777              		.loc 1 298 0 discriminator 1
 778 0034 0010A0E3 		mov	r1, #0
 297:src/main.c    **** 	  res[a] = ADC_Read (a);
 779              		.loc 1 297 0 discriminator 1
 780 0038 0030A0E1 		mov	r3, r0
 298:src/main.c    **** 	  printf ("  %x....%4x\t", a, res[a]);
 781              		.loc 1 298 0 discriminator 1
 782 003c 0020A0E1 		mov	r2, r0
 783 0040 80019FE5 		ldr	r0, .L75+16
 297:src/main.c    **** 	  res[a] = ADC_Read (a);
 784              		.loc 1 297 0 discriminator 1
 785 0044 003084E5 		str	r3, [r4, #0]
 298:src/main.c    **** 	  printf ("  %x....%4x\t", a, res[a]);
 786              		.loc 1 298 0 discriminator 1
 787 0048 FEFFFFEB 		bl	printf
 788              	.LVL43:
 297:src/main.c    **** 	  res[a] = ADC_Read (a);
 789              		.loc 1 297 0 discriminator 1
 790 004c 0100A0E3 		mov	r0, #1
 791 0050 FEFFFFEB 		bl	ADC_Read
 298:src/main.c    **** 	  printf ("  %x....%4x\t", a, res[a]);
 792              		.loc 1 298 0 discriminator 1
 793 0054 0110A0E3 		mov	r1, #1
 297:src/main.c    **** 	  res[a] = ADC_Read (a);
 794              		.loc 1 297 0 discriminator 1
 795 0058 00C0A0E1 		mov	ip, r0
 298:src/main.c    **** 	  printf ("  %x....%4x\t", a, res[a]);
 796              		.loc 1 298 0 discriminator 1
 797 005c 0020A0E1 		mov	r2, r0
 798 0060 60019FE5 		ldr	r0, .L75+16
 297:src/main.c    **** 	  res[a] = ADC_Read (a);
 799              		.loc 1 297 0 discriminator 1
 800 0064 04C084E5 		str	ip, [r4, #4]
 298:src/main.c    **** 	  printf ("  %x....%4x\t", a, res[a]);
 801              		.loc 1 298 0 discriminator 1
 802 0068 FEFFFFEB 		bl	printf
 803              	.LVL44:
 297:src/main.c    **** 	  res[a] = ADC_Read (a);
 804              		.loc 1 297 0 discriminator 1
 805 006c 0200A0E3 		mov	r0, #2
 806 0070 FEFFFFEB 		bl	ADC_Read
 298:src/main.c    **** 	  printf ("  %x....%4x\t", a, res[a]);
 807              		.loc 1 298 0 discriminator 1
 808 0074 0210A0E3 		mov	r1, #2
 297:src/main.c    **** 	  res[a] = ADC_Read (a);
 809              		.loc 1 297 0 discriminator 1
 810 0078 0030A0E1 		mov	r3, r0
 298:src/main.c    **** 	  printf ("  %x....%4x\t", a, res[a]);
 811              		.loc 1 298 0 discriminator 1
 812 007c 0020A0E1 		mov	r2, r0
 813 0080 40019FE5 		ldr	r0, .L75+16
 297:src/main.c    **** 	  res[a] = ADC_Read (a);
 814              		.loc 1 297 0 discriminator 1
 815 0084 083084E5 		str	r3, [r4, #8]
 298:src/main.c    **** 	  printf ("  %x....%4x\t", a, res[a]);
 816              		.loc 1 298 0 discriminator 1
 817 0088 FEFFFFEB 		bl	printf
 818              	.LVL45:
 297:src/main.c    **** 	  res[a] = ADC_Read (a);
 819              		.loc 1 297 0 discriminator 1
 820 008c 0300A0E3 		mov	r0, #3
 821 0090 FEFFFFEB 		bl	ADC_Read
 298:src/main.c    **** 	  printf ("  %x....%4x\t", a, res[a]);
 822              		.loc 1 298 0 discriminator 1
 823 0094 0310A0E3 		mov	r1, #3
 297:src/main.c    **** 	  res[a] = ADC_Read (a);
 824              		.loc 1 297 0 discriminator 1
 825 0098 00C0A0E1 		mov	ip, r0
 298:src/main.c    **** 	  printf ("  %x....%4x\t", a, res[a]);
 826              		.loc 1 298 0 discriminator 1
 827 009c 0020A0E1 		mov	r2, r0
 828 00a0 20019FE5 		ldr	r0, .L75+16
 297:src/main.c    **** 	  res[a] = ADC_Read (a);
 829              		.loc 1 297 0 discriminator 1
 830 00a4 0CC084E5 		str	ip, [r4, #12]
 298:src/main.c    **** 	  printf ("  %x....%4x\t", a, res[a]);
 831              		.loc 1 298 0 discriminator 1
 832 00a8 FEFFFFEB 		bl	printf
 833              	.LVL46:
 297:src/main.c    **** 	  res[a] = ADC_Read (a);
 834              		.loc 1 297 0 discriminator 1
 835 00ac 0400A0E3 		mov	r0, #4
 836 00b0 FEFFFFEB 		bl	ADC_Read
 298:src/main.c    **** 	  printf ("  %x....%4x\t", a, res[a]);
 837              		.loc 1 298 0 discriminator 1
 838 00b4 0410A0E3 		mov	r1, #4
 297:src/main.c    **** 	  res[a] = ADC_Read (a);
 839              		.loc 1 297 0 discriminator 1
 840 00b8 0030A0E1 		mov	r3, r0
 298:src/main.c    **** 	  printf ("  %x....%4x\t", a, res[a]);
 841              		.loc 1 298 0 discriminator 1
 842 00bc 0020A0E1 		mov	r2, r0
 843 00c0 00019FE5 		ldr	r0, .L75+16
 297:src/main.c    **** 	  res[a] = ADC_Read (a);
 844              		.loc 1 297 0 discriminator 1
 845 00c4 103084E5 		str	r3, [r4, #16]
 298:src/main.c    **** 	  printf ("  %x....%4x\t", a, res[a]);
 846              		.loc 1 298 0 discriminator 1
 847 00c8 FEFFFFEB 		bl	printf
 848              	.LVL47:
 297:src/main.c    **** 	  res[a] = ADC_Read (a);
 849              		.loc 1 297 0 discriminator 1
 850 00cc 0500A0E3 		mov	r0, #5
 851 00d0 FEFFFFEB 		bl	ADC_Read
 298:src/main.c    **** 	  printf ("  %x....%4x\t", a, res[a]);
 852              		.loc 1 298 0 discriminator 1
 853 00d4 0510A0E3 		mov	r1, #5
 297:src/main.c    **** 	  res[a] = ADC_Read (a);
 854              		.loc 1 297 0 discriminator 1
 855 00d8 00C0A0E1 		mov	ip, r0
 298:src/main.c    **** 	  printf ("  %x....%4x\t", a, res[a]);
 856              		.loc 1 298 0 discriminator 1
 857 00dc 0020A0E1 		mov	r2, r0
 858 00e0 E0009FE5 		ldr	r0, .L75+16
 297:src/main.c    **** 	  res[a] = ADC_Read (a);
 859              		.loc 1 297 0 discriminator 1
 860 00e4 14C084E5 		str	ip, [r4, #20]
 298:src/main.c    **** 	  printf ("  %x....%4x\t", a, res[a]);
 861              		.loc 1 298 0 discriminator 1
 862 00e8 FEFFFFEB 		bl	printf
 863              	.LVL48:
 297:src/main.c    **** 	  res[a] = ADC_Read (a);
 864              		.loc 1 297 0 discriminator 1
 865 00ec 0600A0E3 		mov	r0, #6
 866 00f0 FEFFFFEB 		bl	ADC_Read
 298:src/main.c    **** 	  printf ("  %x....%4x\t", a, res[a]);
 867              		.loc 1 298 0 discriminator 1
 868 00f4 0610A0E3 		mov	r1, #6
 297:src/main.c    **** 	  res[a] = ADC_Read (a);
 869              		.loc 1 297 0 discriminator 1
 870 00f8 0030A0E1 		mov	r3, r0
 298:src/main.c    **** 	  printf ("  %x....%4x\t", a, res[a]);
 871              		.loc 1 298 0 discriminator 1
 872 00fc 0020A0E1 		mov	r2, r0
 873 0100 C0009FE5 		ldr	r0, .L75+16
 297:src/main.c    **** 	  res[a] = ADC_Read (a);
 874              		.loc 1 297 0 discriminator 1
 875 0104 183084E5 		str	r3, [r4, #24]
 298:src/main.c    **** 	  printf ("  %x....%4x\t", a, res[a]);
 876              		.loc 1 298 0 discriminator 1
 877 0108 FEFFFFEB 		bl	printf
 878              	.LVL49:
 297:src/main.c    **** 	  res[a] = ADC_Read (a);
 879              		.loc 1 297 0 discriminator 1
 880 010c 0700A0E3 		mov	r0, #7
 881 0110 FEFFFFEB 		bl	ADC_Read
 298:src/main.c    **** 	  printf ("  %x....%4x\t", a, res[a]);
 882              		.loc 1 298 0 discriminator 1
 883 0114 0710A0E3 		mov	r1, #7
 297:src/main.c    **** 	  res[a] = ADC_Read (a);
 884              		.loc 1 297 0 discriminator 1
 885 0118 00C0A0E1 		mov	ip, r0
 298:src/main.c    **** 	  printf ("  %x....%4x\t", a, res[a]);
 886              		.loc 1 298 0 discriminator 1
 887 011c 0020A0E1 		mov	r2, r0
 888 0120 A0009FE5 		ldr	r0, .L75+16
 297:src/main.c    **** 	  res[a] = ADC_Read (a);
 889              		.loc 1 297 0 discriminator 1
 890 0124 1CC084E5 		str	ip, [r4, #28]
 298:src/main.c    **** 	  printf ("  %x....%4x\t", a, res[a]);
 891              		.loc 1 298 0 discriminator 1
 892 0128 FEFFFFEB 		bl	printf
 893              	.LVL50:
 300:src/main.c    ****       printf ("\n");
 894              		.loc 1 300 0 discriminator 1
 895 012c 0A00A0E3 		mov	r0, #10
 896 0130 FEFFFFEB 		bl	putchar
 301:src/main.c    ****       white += ((res[1] + res[3] + res[4]) / 3);
 897              		.loc 1 301 0 discriminator 1
 898 0134 043094E5 		ldr	r3, [r4, #4]
 899 0138 0C1084E2 		add	r1, r4, #12
 900 013c 021091E8 		ldmia	r1, {r1, ip}	@ phole ldm
 901 0140 032081E0 		add	r2, r1, r3
 902 0144 0C0082E0 		add	r0, r2, ip
 903 0148 983080E0 		umull	r3, r0, r8, r0
 302:src/main.c    ****       black += (res[2]);
 904              		.loc 1 302 0 discriminator 1
 905 014c 001096E5 		ldr	r1, [r6, #0]
 301:src/main.c    ****       white += ((res[1] + res[3] + res[4]) / 3);
 906              		.loc 1 301 0 discriminator 1
 907 0150 003097E5 		ldr	r3, [r7, #0]
 302:src/main.c    ****       black += (res[2]);
 908              		.loc 1 302 0 discriminator 1
 909 0154 08C094E5 		ldr	ip, [r4, #8]
 301:src/main.c    ****       white += ((res[1] + res[3] + res[4]) / 3);
 910              		.loc 1 301 0 discriminator 1
 911 0158 A02083E0 		add	r2, r3, r0, lsr #1
 293:src/main.c    ****   for (white = 0, black = 0, i = 1; i <= 20; i++)
 912              		.loc 1 293 0 discriminator 1
 913 015c 015055E2 		subs	r5, r5, #1
 302:src/main.c    ****       black += (res[2]);
 914              		.loc 1 302 0 discriminator 1
 915 0160 0C0081E0 		add	r0, r1, ip
 301:src/main.c    ****       white += ((res[1] + res[3] + res[4]) / 3);
 916              		.loc 1 301 0 discriminator 1
 917 0164 002087E5 		str	r2, [r7, #0]
 302:src/main.c    ****       black += (res[2]);
 918              		.loc 1 302 0 discriminator 1
 919 0168 000086E5 		str	r0, [r6, #0]
 293:src/main.c    ****   for (white = 0, black = 0, i = 1; i <= 20; i++)
 920              		.loc 1 293 0 discriminator 1
 921 016c AEFFFF1A 		bne	.L68
 922              	.LVL51:
 311:src/main.c    ****       for (a = 0; a <= 4; a++)
 923              		.loc 1 311 0 discriminator 1
 924 0170 040055E3 		cmp	r5, #4
 925 0174 0200009A 		bls	.L70
 926              	.L74:
 317:src/main.c    ****       printf ("\n");
 927              		.loc 1 317 0
 928 0178 0A00A0E3 		mov	r0, #10
 929 017c FEFFFFEB 		bl	putchar
 311:src/main.c    ****       for (a = 0; a <= 4; a++)
 930              		.loc 1 311 0
 931 0180 0050A0E3 		mov	r5, #0
 932              	.LVL52:
 933              	.L70:
 313:src/main.c    **** 	  res[a] = ADC_Read (a);
 934              		.loc 1 313 0 discriminator 2
 935 0184 0500A0E1 		mov	r0, r5
 936 0188 FEFFFFEB 		bl	ADC_Read
 314:src/main.c    **** 	  printf ("%d\t", res[a]);
 937              		.loc 1 314 0 discriminator 2
 938 018c 0010A0E1 		mov	r1, r0
 313:src/main.c    **** 	  res[a] = ADC_Read (a);
 939              		.loc 1 313 0 discriminator 2
 940 0190 0060A0E1 		mov	r6, r0
 314:src/main.c    **** 	  printf ("%d\t", res[a]);
 941              		.loc 1 314 0 discriminator 2
 942 0194 30009FE5 		ldr	r0, .L75+20
 313:src/main.c    **** 	  res[a] = ADC_Read (a);
 943              		.loc 1 313 0 discriminator 2
 944 0198 056184E7 		str	r6, [r4, r5, asl #2]
 314:src/main.c    **** 	  printf ("%d\t", res[a]);
 945              		.loc 1 314 0 discriminator 2
 946 019c FEFFFFEB 		bl	printf
 311:src/main.c    ****       for (a = 0; a <= 4; a++)
 947              		.loc 1 311 0 discriminator 2
 948 01a0 015085E2 		add	r5, r5, #1
 315:src/main.c    **** 	  vTaskDelay (3 / portTICK_RATE_MS);
 949              		.loc 1 315 0 discriminator 2
 950 01a4 0300A0E3 		mov	r0, #3
 951 01a8 FEFFFFEB 		bl	vTaskDelay
 952              	.LVL53:
 311:src/main.c    ****       for (a = 0; a <= 4; a++)
 953              		.loc 1 311 0 discriminator 2
 954 01ac 040055E3 		cmp	r5, #4
 955 01b0 F0FFFF8A 		bhi	.L74
 956 01b4 F2FFFFEA 		b	.L70
 957              	.L76:
 958              		.align	2
 959              	.L75:
 960 01b8 00000000 		.word	.LANCHOR1
 961 01bc 00000000 		.word	.LANCHOR2
 962 01c0 00000000 		.word	.LANCHOR3
 963 01c4 ABAAAAAA 		.word	-1431655765
 964 01c8 64000000 		.word	.LC12
 965 01cc 74000000 		.word	.LC13
 966              		.cfi_endproc
 967              	.LFE6:
 969              		.global	i2cbuff
 970              		.global	i2cErr
 971              		.global	left
 972              		.global	right
 973              		.global	Mutex
 974              		.global	res
 975              		.global	white
 976              		.global	black
 977              		.section	.bss.white,"aw",%nobits
 978              		.align	2
 979              		.set	.LANCHOR1,. + 0
 982              	white:
 983 0000 00000000 		.space	4
 984              		.section	.bss.right,"aw",%nobits
 985              		.align	2
 986              		.set	.LANCHOR4,. + 0
 989              	right:
 990 0000 00000000 		.space	4
 991              		.section	.bss.res,"aw",%nobits
 992              		.align	2
 993              		.set	.LANCHOR3,. + 0
 996              	res:
 997 0000 00000000 		.space	20
 997      00000000 
 997      00000000 
 997      00000000 
 997      00000000 
 998              		.section	.bss.i2cErr,"aw",%nobits
 999              		.align	2
 1002              	i2cErr:
 1003 0000 00000000 		.space	4
 1004              		.section	.bss.i2cbuff,"aw",%nobits
 1005              		.align	2
 1008              	i2cbuff:
 1009 0000 00000000 		.space	24
 1009      00000000 
 1009      00000000 
 1009      00000000 
 1009      00000000 
 1010              		.section	.bss.left,"aw",%nobits
 1011              		.align	2
 1012              		.set	.LANCHOR5,. + 0
 1015              	left:
 1016 0000 00000000 		.space	4
 1017              		.section	.rodata.str1.4,"aMS",%progbits,1
 1018              		.align	2
 1019              	.LC0:
 1020 0000 25347800 		.ascii	"%4x\000"
 1021              	.LC1:
 1022 0004 257800   		.ascii	"%x\000"
 1023 0007 00       		.space	1
 1024              	.LC2:
 1025 0008 48656C6C 		.ascii	"Hello,\000"
 1025      6F2C00
 1026 000f 00       		.space	1
 1027              	.LC3:
 1028 0010 20776F72 		.ascii	" world!\000"
 1028      6C642100 
 1029              	.LC4:
 1030 0018 69737372 		.ascii	"issr\000"
 1030      00
 1031 001d 000000   		.space	3
 1032              	.LC5:
 1033 0020 4C4400   		.ascii	"LD\000"
 1034 0023 00       		.space	1
 1035              	.LC6:
 1036 0024 73746172 		.ascii	"start ISSI connection\000"
 1036      74204953 
 1036      53492063 
 1036      6F6E6E65 
 1036      6374696F 
 1037 003a 0000     		.space	2
 1038              	.LC7:
 1039 003c 7072763D 		.ascii	"prv=%x\000"
 1039      257800
 1040 0043 00       		.space	1
 1041              	.LC8:
 1042 0044 43723D25 		.ascii	"Cr=%d\000"
 1042      6400
 1043 004a 0000     		.space	2
 1044              	.LC9:
 1045 004c 2D256409 		.ascii	"-%d\011%d\012\000"
 1045      25640A00 
 1046              	.LC10:
 1047 0054 6D696769 		.ascii	"migi\000"
 1047      00
 1048 0059 000000   		.space	3
 1049              	.LC11:
 1050 005c 7479756F 		.ascii	"tyuou\000"
 1050      7500
 1051 0062 0000     		.space	2
 1052              	.LC12:
 1053 0064 20202578 		.ascii	"  %x....%4x\011\000"
 1053      2E2E2E2E 
 1053      25347809 
 1053      00
 1054 0071 000000   		.space	3
 1055              	.LC13:
 1056 0074 25640900 		.ascii	"%d\011\000"
 1057              		.section	.bss.Mutex,"aw",%nobits
 1058              		.align	2
 1059              		.set	.LANCHOR0,. + 0
 1062              	Mutex:
 1063 0000 00000000 		.space	4
 1064              		.section	.bss.black,"aw",%nobits
 1065              		.align	2
 1066              		.set	.LANCHOR2,. + 0
 1069              	black:
 1070 0000 00000000 		.space	4
 1071              		.text
 1072              	.Letext0:
DEFINED SYMBOLS
                            *ABS*:00000000 main.c
     /tmp/cc4eaIqO.s:22     .text.ISSR:00000000 $a
     /tmp/cc4eaIqO.s:24     .text.ISSR:00000000 ISSR
     /tmp/cc4eaIqO.s:231    .text.ISSR:000001d0 $d
     /tmp/cc4eaIqO.s:241    .text.main:00000000 $a
     /tmp/cc4eaIqO.s:244    .text.main:00000000 main
     /tmp/cc4eaIqO.s:354    .text.main:000000c8 $d
     /tmp/cc4eaIqO.s:367    .text.getISSI:00000000 $a
     /tmp/cc4eaIqO.s:370    .text.getISSI:00000000 getISSI
     /tmp/cc4eaIqO.s:456    .text.getISSI:00000098 $d
     /tmp/cc4eaIqO.s:467    .text.vApplicationTickHook:00000000 $a
     /tmp/cc4eaIqO.s:470    .text.vApplicationTickHook:00000000 vApplicationTickHook
     /tmp/cc4eaIqO.s:484    .text.vtrsTask:00000000 $a
     /tmp/cc4eaIqO.s:487    .text.vtrsTask:00000000 vtrsTask
     /tmp/cc4eaIqO.s:604    .text.vtrsTask:00000104 $d
     /tmp/cc4eaIqO.s:615    .text.ADC_Read:00000000 $a
     /tmp/cc4eaIqO.s:618    .text.ADC_Read:00000000 ADC_Read
     /tmp/cc4eaIqO.s:645    .text.ADC_Read:00000030 $d
     /tmp/cc4eaIqO.s:655    .text.ADC_Read:00000050 $a
     /tmp/cc4eaIqO.s:729    .text.ADC_Read:000000d8 $d
     /tmp/cc4eaIqO.s:734    .text.vValueTask:00000000 $a
     /tmp/cc4eaIqO.s:737    .text.vValueTask:00000000 vValueTask
     /tmp/cc4eaIqO.s:960    .text.vValueTask:000001b8 $d
     /tmp/cc4eaIqO.s:1008   .bss.i2cbuff:00000000 i2cbuff
     /tmp/cc4eaIqO.s:1002   .bss.i2cErr:00000000 i2cErr
     /tmp/cc4eaIqO.s:1015   .bss.left:00000000 left
     /tmp/cc4eaIqO.s:989    .bss.right:00000000 right
     /tmp/cc4eaIqO.s:1062   .bss.Mutex:00000000 Mutex
     /tmp/cc4eaIqO.s:996    .bss.res:00000000 res
     /tmp/cc4eaIqO.s:982    .bss.white:00000000 white
     /tmp/cc4eaIqO.s:1069   .bss.black:00000000 black
     /tmp/cc4eaIqO.s:978    .bss.white:00000000 $d
     /tmp/cc4eaIqO.s:985    .bss.right:00000000 $d
     /tmp/cc4eaIqO.s:992    .bss.res:00000000 $d
     /tmp/cc4eaIqO.s:999    .bss.i2cErr:00000000 $d
     /tmp/cc4eaIqO.s:1005   .bss.i2cbuff:00000000 $d
     /tmp/cc4eaIqO.s:1011   .bss.left:00000000 $d
     /tmp/cc4eaIqO.s:1018   .rodata.str1.4:00000000 $d
     /tmp/cc4eaIqO.s:1058   .bss.Mutex:00000000 $d
     /tmp/cc4eaIqO.s:1065   .bss.black:00000000 $d
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
vTaskDelay
GPIOInit
xQueueGenericReceive
printf
fflush
putchar
_impure_ptr
TargetResetInit
GPIOResetInit
xQueueCreateMutex
puts
xTaskGenericCreate
vTaskStartScheduler
vi2c
